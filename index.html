<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Volumetric Persistence Playground</title>
  <style>
    body { font-family: sans-serif; max-width: 960px; margin: auto; padding: 1rem; }
    .controls { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem; }
    .controls label { display: flex; flex-direction: column; font-size: 0.9rem; }
    .controls input, .controls select { margin-top: 0.3rem; }
    .plot { margin-top: 1.5rem; }
    .plot img { width: 100%; border: 1px solid #ccc; }
  </style>
</head>
<body>

  <h1>Volumetric-Persistence Peak-Detection Playground</h1>
  <p>Tweak the number of peaks, noise amount/type, and click “Run”. All plots update.</p>

  <div class="controls">
    <label>
      # of peaks
      <input type="number" id="num_peaks" min="1" max="6" value="3">
    </label>
    <label>
      Noise level
      <input type="range" id="noise_level" min="0" max="0.2" step="0.005" value="0.05">
      <span id="noise_val">0.05</span>
    </label>
    <label>
      Noise type
      <select id="noise_type">
        <option value="gaussian" selected>Gaussian</option>
        <option value="uniform">Uniform</option>
      </select>
    </label>
    <button id="run">Run</button>
  </div>

  <div class="plot">
    <h3>Spectrum + Detected Peaks</h3>
    <img id="spec_img" alt="Spectrum">
  </div>
  <div class="plot">
    <h3>Volumetric-Persistence Barcode</h3>
    <img id="barcode_img" alt="Barcode">
  </div>
  <div class="plot">
    <h3>Inner-Grid (First Peak)</h3>
    <img id="inner_img" alt="Inner grid">
  </div>
  <div class="plot">
    <h3>Multi-Peak Persistence Radar</h3>
    <img id="radar_img" alt="Radar chart">
  </div>

  <!-- Pyodide loader -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
  <script>
    (function() {
      const pyodideReadyPromise = loadPyodide({
        indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.23.4/full/'
      }).then(async pyodide => {
        await pyodide.loadPackage(['numpy','scipy','matplotlib']);
        await pyodide.runPythonAsync(`
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
from io import BytesIO
import base64

def synthetic(n_peaks, noise_lvl, noise_type):
    x = np.linspace(0, 1000, 1000)
    rng = np.random.default_rng(42)
    centers = np.linspace(200, 800, n_peaks)
    spectrum = sum(np.exp(-((x-c)/10)**2) for c in centers)
    if noise_lvl > 0:
        if noise_type=='gaussian':
            spectrum += noise_lvl * rng.standard_normal(x.shape)
        else:
            spectrum += rng.uniform(-noise_lvl, noise_lvl, x.shape)
    return x, spectrum

def find_volumetric_peaks(spectrum):
    smoothing_range = [0,3,5]
    bins_range = [1,2]
    threshold_range = np.linspace(0,0.15,10)
    width_range = np.linspace(1,50,10)
    prominence_range = np.linspace(0.01,1.0,10)
    distance_range = [1,5,10,15,20]
    merging = 10
    cell_vol = 1.0
    candidates = {}
    for s in smoothing_range:
        spec_s = spectrum if s<2 else np.convolve(spectrum, np.ones(s)/s, 'same')
        for b in bins_range:
            if b>1:
                trim = len(spec_s) % b
                spec_b = spec_s[:-trim] if trim else spec_s
                proc = spec_b.reshape(-1,b).mean(1)
                map_fn = lambda i, b=b: int(round(i*b + b/2))
            else:
                proc = spec_s
                map_fn = lambda i: i
            for thr in threshold_range:
                for wid in width_range:
                    for prom in prominence_range:
                        for dist in distance_range:
                            peaks, _ = find_peaks(proc, threshold=thr, width=wid, prominence=prom, distance=dist)
                            for p in peaks:
                                key = (s,b,p)
                                if key not in candidates:
                                    candidates[key] = {'count':0,'agg':p,'map_fn':map_fn,'params':[]}
                                candidates[key]['count'] += 1
                                candidates[key]['params'].append({'s':s,'b':b,'thr':thr,'wid':wid,'prom':prom,'dist':dist})
    merged = []
    for c in candidates.values():
        orig = c['map_fn'](c['agg'])
        pers = c['count']*cell_vol
        added = False
        for m in merged:
            if abs(orig - m['idx']) <= merging:
                total = m['pers'] + pers
                m['idx'] = int(round((m['idx']*m['pers'] + orig*pers)/total))
                m['pers'] += pers
                m['params'] += c['params']
                added = True
                break
        if not added:
            merged.append({'idx':orig,'pers':pers,'params':c['params']})
    merged.sort(key=lambda x: -x['pers'])
    return merged[:30]

def plot_and_encode(fig):
    buf = BytesIO()
    fig.tight_layout()
    fig.savefig(buf, format='png')
    buf.seek(0)
    return base64.b64encode(buf.read()).decode('ascii')

def generate_and_plots(n_p, noise_lvl, noise_type):
    x, y = synthetic(n_p, noise_lvl, noise_type)
    peaks = find_volumetric_peaks(y)
    # Plot 1
    fig1, ax1 = plt.subplots(figsize=(8,2.5))
    ax1.plot(x, y, color='#8499C4', lw=1)
    for i, pk in enumerate(peaks[:4]): ax1.axvline(pk['idx'], color=['#C94040','#69995D','#CBAC88','#394648'][i], linestyle='--')
    ax1.set(xlabel='Channel', ylabel='Intensity'); ax1.grid(True)
    spec_png = plot_and_encode(fig1); plt.close(fig1)
    # Plot 2
    fig2 = plt.figure(figsize=(8,2))
    for i, pk in enumerate(peaks): plt.vlines(pk['idx'], 0, pk['pers'], color=(['#C94040','#69995D','#CBAC88','#394648'][i] if i<4 else '#CCCCCC'), linewidth=2)
    plt.xlabel('Channel'); plt.ylabel('Persistence'); plt.grid(True)
    barcode_png = plot_and_encode(fig2); plt.close(fig2)
    # Plot 3
    fig3 = plt.figure(figsize=(5,4)); ax3 = fig3.add_subplot(111, projection='3d')
    if peaks:
        p0 = peaks[0]['params']; pts = [(p['thr'],p['wid'],p['prom']) for p in p0 if p['dist']==10]
        if pts:
            arr = np.array(pts); counts = [pts.count(tuple(a)) for a in pts]
            sc = ax3.scatter(arr[:,0], arr[:,1], arr[:,2], s=np.array(counts)*20, c=counts, cmap='viridis')
            fig3.colorbar(sc, ax=ax3, label='Frequency')
    ax3.set(xlabel='Threshold', ylabel='Width', zlabel='Prominence')
    inner_png = plot_and_encode(fig3); plt.close(fig3)
    # Plot 4
    labels = ['smoothing','b','thr','wid','prom','dist']; angles = list(np.linspace(0,2*np.pi,len(labels),endpoint=False)) + [0]
    fig4 = plt.figure(figsize=(4,4)); ax4 = fig4.add_subplot(111, polar=True)
    for i, pk in enumerate(peaks[:4]):
        vals = []
        for L in labels:
            vs = sorted({p[L] for p in pk['params']}); rng = max(vs)-min(vs) if len(vs)>1 else 0; segs = sum(np.diff(vs)) if rng>0 else 0
            vals.append(segs/rng if rng>0 else 0)
        vals += vals[:1]
        ax4.plot(angles, vals, linewidth=2, label=f"Peak {pk['idx']}"); ax4.fill(angles, vals, alpha=0.1)
    ax4.set_xticks(angles[:-1]); ax4.set_xticklabels(labels, fontsize=8); ax4.set_yticklabels([])
    ax4.legend(loc='upper right', bbox_to_anchor=(1.3,1.1), fontsize=7)
    radar_png = plot_and_encode(fig4); plt.close(fig4)
    return spec_png, barcode_png, inner_png, radar_png
`);
        return pyodide;
      }).catch(console.error);

      document.getElementById('noise_level').addEventListener('input', e => {
        document.getElementById('noise_val').textContent = e.target.value;
      });

      document.getElementById('run').addEventListener('click', async () => {
        const pyodide = await pyodideReadyPromise;
        const n = parseInt(document.getElementById('num_peaks').value, 10);
        const nl = parseFloat(document.getElementById('noise_level').value);
        const nt = document.getElementById('noise_type').value;
        // Get results as a PyProxy, then convert to JS array
        const resultPy = await pyodide.runPythonAsync(`generate_and_plots(${n}, ${nl}, '${nt}')`);
        const [specB64, barcodeB64, innerB64, radarB64] = resultPy.toJs();
        document.getElementById('spec_img').src    = `data:image/png;base64,${specB64}`;
        document.getElementById('barcode_img').src = `data:image/png;base64,${barcodeB64}`;
        document.getElementById('inner_img').src   = `data:image/png;base64,${innerB64}`;
        document.getElementById('radar_img').src   = `data:image/png;base64,${radarB64}`;
        resultPy.destroy();  // free the proxy
      });
    })();
  </script>
</body>
</html>
